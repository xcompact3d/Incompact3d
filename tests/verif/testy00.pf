module testy00

   use MPI
   use pFunit
   use iso_c_binding
   use x3d_unit_testing_tools
   implicit none

contains

   ! Serial test
   @test
   subroutine verif_ibm_dery_ibm_deryy_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf
      use ibm, only : ubcx,ubcy,ubcz

      implicit none

      real(mytype), dimension(ysize(1),ysize(2),ysize(3)) :: input, output, tmp, sol
      real(mytype) :: y, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: j

      ! Lx = Ly = Lz = 2
      do j = 1, ysize(2)
         y = yp(j)
         input(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo

      ! test ibm_dery
      do j = 1, ysize(2)
         y = yp(j)
         sol(:,j,:) = pi*cos(pi*y) - 5*pi*sin(5*pi*y)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call ibm_dery(output,input,di2,sy,ffy,fsy,fwy,ppy,ysize(1),ysize(2),ysize(3),0,ubcx)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call log("dery00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=4.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=4.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif
      call cpu_time(t1)
      call ibm_dery(output,input,di2,sy,ffyp,fsyp,fwyp,ppy,ysize(1),ysize(2),ysize(3),1,ubcy)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call log("dery00p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=4.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=4.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif

      ! test ibm_deryy
      iimplicit = -iimplicit
      do j = 1, ysize(2)
         y = yp(j)
         sol(:,j,:) = -(pi**2)*sin(pi*y) - 25*(pi**2)*cos(5*pi*y)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call ibm_deryy(output,input,di2,sy,sfyp,ssyp,swyp,ysize(1),ysize(2),ysize(3),1,ubcx)
      if (istret /= 0) then
         call ibm_dery(tmp,input,di2,sy,ffyp,fsyp,fwyp,ppy,ysize(1),ysize(2),ysize(3),1,ubcx)
         do j = 1, ysize(2)
            output(:,j,:) = output(:,j,:)*pp2y(j)-pp4y(j)*tmp(:,j,:)
         enddo
      endif
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call log("deryy00p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-12)
         @assertEqual(l2/sl2, 0.d0, tolerance=3.d-12)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif
      call cpu_time(t1)
      call ibm_deryy(output,input,di2,sy,sfy,ssy,swy,ysize(1),ysize(2),ysize(3),0,ubcy)
      if (istret /= 0) then
         call ibm_dery(tmp,input,di2,sy,ffy,fsy,fwy,ppy,ysize(1),ysize(2),ysize(3),0,ubcy)
         do j = 1, ysize(2)
            output(:,j,:) = output(:,j,:)*pp2y(j)-pp4y(j)*tmp(:,j,:)
         enddo
      endif
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call log("deryy00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-12)
         @assertEqual(l2/sl2, 0.d0, tolerance=3.d-12)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif
      iimplicit = -iimplicit

   end subroutine verif_ibm_dery_ibm_deryy_00

   ! Serial test
   @test
   subroutine verif_deryvp_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(ysize(1),ysize(2),ysize(3)) :: input, diloc
      real(mytype), dimension(ysize(1),nymsize,ysize(3)) :: output, sol
      real(mytype) :: y, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: j

      ! Lx = Ly = Lz = 2
      do j = 1, ysize(2)
         y = yp(j)
         input(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo

      ! test deryvp
      do j = 1, nymsize
         y = ypi(j)
         sol(:,j,:) = pi*cos(pi*y) - 5*pi*sin(5*pi*y)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, ysize(1), nymsize, ysize(3), xsize(1)*nymsize*zsize(3))
      call cpu_time(t1)
      call deryvp(output,input,diloc,sy,cfy6,csy6,cwy6,ppyi,ysize(1),ysize(2),nymsize,ysize(3),0)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), nymsize, ysize(3), xsize(1)*nymsize*zsize(3))
      call log("deryvp00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-13)
      endif

   end subroutine verif_deryvp_00

   ! Serial test
   @test
   subroutine verif_interyvp_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(ysize(1),ysize(2),ysize(3)) :: input, diloc
      real(mytype), dimension(ysize(1),nymsize,ysize(3)) :: output, sol
      real(mytype) :: y, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: j

      ! Lx = Ly = Lz = 2
      do j = 1, ysize(2)
         y = yp(j)
         input(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo

      ! test deryvp
      do j = 1, nymsize
         y = ypi(j)
         sol(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, ysize(1), nymsize, ysize(3), xsize(1)*nymsize*zsize(3))
      call cpu_time(t1)
      call interyvp(output,input,diloc,sz,cifyp6,cisyp6,ciwyp6,ysize(1),ysize(2),nymsize,ysize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), nymsize, ysize(3), xsize(1)*nymsize*zsize(3))
      call log("interyvp00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=7.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=6.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif

   end subroutine verif_interyvp_00

   ! Serial test
   @test
   subroutine verif_derypv_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(ysize(1),nymsize,ysize(3)) :: input
      real(mytype), dimension(ysize(1),ysize(2),ysize(3)) :: diloc, output, sol
      real(mytype) :: y, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: j

      ! Lx = Ly = Lz = 2
      do j = 1, nymsize
         y = ypi(j)
         input(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo

      ! test deryvp
      do j = 1, ysize(2)
         y = yp(j)
         sol(:,j,:) = pi*cos(pi*y) - 5*pi*sin(5*pi*y)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call derypv(output,input,diloc,sy,cfip6y,csip6y,cwip6y,cfy6,csy6,cwy6,ppy,ysize(1),nymsize,ysize(2),ysize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call log("derypv00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-13)
      endif

   end subroutine verif_derypv_00

   ! Serial test
   @test
   subroutine verif_interypv_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(ysize(1),nymsize,ysize(3)) :: input
      real(mytype), dimension(ysize(1),ysize(2),ysize(3)) :: diloc, output, sol
      real(mytype) :: y, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: j

      ! Lx = Ly = Lz = 2
      do j = 1, nymsize
         y = ypi(j)
         input(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo

      ! test deryvp
      do j = 1, ysize(2)
         y = yp(j)
         sol(:,j,:) = sin(pi*y) + cos(5*pi*y)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call interypv(output,input,diloc,sz,cifip6y,cisip6y,ciwip6y,cify6,cisy6,ciwy6,ysize(1),nymsize,ysize(2),ysize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, ysize(1), ysize(2), ysize(3), xsize(1)*ysize(2)*zsize(3))
      call log("interypv00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=7.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=6.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif

   end subroutine verif_interypv_00

   ! Serial test
   @test
   subroutine verif_ibm_fily_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf
      use ibm, only : ubcx,ubcy,ubcz

      implicit none

      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: input, output, sol
      real(mytype) :: y, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: j

      call filter(zero)

      ! Lx = Ly = Lz = 2
      do j = 1, ysize(2)
         y = (j-1) * dy
         input(:,j,:) = sin(pi*y) + cos(5*pi*y)
         sol(:,j,:) = input(:,j,:)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call ibm_fily(output,input,di2,fisy,fiffyp,fifsyp,fifwyp,ysize(1),ysize(2),ysize(3),1,ubcx)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("fily00p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-11)
         @assertEqual(l2/sl2, 0.d0, tolerance=1.d-11)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif
      call cpu_time(t1)
      call ibm_fily(output,input,di2,fisy,fiffy ,fifsy ,fifwy ,ysize(1),ysize(2),ysize(3),0,ubcy)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("fily00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-11)
         @assertEqual(l2/sl2, 0.d0, tolerance=1.d-11)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif

   end subroutine verif_ibm_fily_00

end module testy00
