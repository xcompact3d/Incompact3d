module testx00

   use MPI
   use pFunit
   use iso_c_binding
   use x3d_unit_testing_tools
   implicit none

contains

   ! Serial test
   @test
   subroutine verif_derx_derxx_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: input, output, sol
      real(mytype) :: x, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: i

      ! Lx = Ly = Lz = 2
      do i = 1, xsize(1)
         x = (i-1) * dx
         input(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo

      ! test derx
      do i = 1, xsize(1)
         x = (i-1) * dx
         sol(i,:,:) = pi*cos(pi*x) - 5*pi*sin(5*pi*x)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call derx(output,input,di1,sx,ffxp,fsxp,fwxp,xsize(1),xsize(2),xsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("derx00p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=4.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=4.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif
      call cpu_time(t1)
      call derx(output,input,di1,sx,ffx,fsx,fwx,xsize(1),xsize(2),xsize(3),0)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("derx00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=4.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=4.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif

      ! test derxx
      do i = 1, xsize(1)
         x = (i-1) * dx
         sol(i,:,:) = -(pi**2)*sin(pi*x) - 25*(pi**2)*cos(5*pi*x)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call derxx(output,input,di1,sx,sfx,ssx,swx,xsize(1),xsize(2),xsize(3),0)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("derxx00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-12)
         @assertEqual(l2/sl2, 0.d0, tolerance=3.d-12)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif
      call cpu_time(t1)
      call derxx(output,input,di1,sx,sfxp,ssxp,swxp,xsize(1),xsize(2),xsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("derxx00p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-12)
         @assertEqual(l2/sl2, 0.d0, tolerance=3.d-12)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif

   end subroutine verif_derx_derxx_00

   ! Serial test
   @test
   subroutine verif_derxvp_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: input, diloc
      real(mytype), dimension(nxmsize,xsize(2),xsize(3)) :: output, sol
      real(mytype) :: x, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: i

      ! Lx = Ly = Lz = 2
      do i = 1, xsize(1)
         x = (i-1) * dx
         input(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo

      ! test derxvp
      do i = 1, nxmsize
         x = (i-half) * dx
         sol(i,:,:) = pi*cos(pi*x) - 5*pi*sin(5*pi*x)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, nxmsize, xsize(2), xsize(3), nxmsize*ysize(2)*zsize(3))
      call cpu_time(t1)
      call derxvp(output,input,diloc,sx,cfx6,csx6,cwx6,xsize(1),nxmsize,xsize(2),xsize(3),0)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, nxmsize, xsize(2), xsize(3), nxmsize*ysize(2)*zsize(3))
      call log("derxvp00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-13)
      endif

   end subroutine verif_derxvp_00

   ! Serial test
   @test
   subroutine verif_interxvp_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: input, diloc
      real(mytype), dimension(nxmsize,xsize(2),xsize(3)) :: output, sol
      real(mytype) :: x, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: i

      ! Lx = Ly = Lz = 2
      do i = 1, xsize(1)
         x = (i-1) * dx
         input(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo

      ! test derxvp
      do i = 1, nxmsize
         x = (i-half) * dx
         sol(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, nxmsize, xsize(2), xsize(3), nxmsize*ysize(2)*zsize(3))
      call cpu_time(t1)
      call interxvp(output,input,diloc,sx,cifxp6,cisxp6,ciwxp6,xsize(1),nxmsize,xsize(2),xsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, nxmsize, xsize(2), xsize(3), nxmsize*ysize(2)*zsize(3))
      call log("interxvp00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=7.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=6.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif

   end subroutine verif_interxvp_00

   ! Serial test
   @test
   subroutine verif_derxpv_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(nxmsize,xsize(2),xsize(3)) :: input
      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: diloc, output, sol
      real(mytype) :: x, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: i

      ! Lx = Ly = Lz = 2
      do i = 1, nxmsize
         x = (i-half) * dx
         input(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo

      ! test derxvp
      do i = 1, xsize(1)
         x = (i-1) * dx
         sol(i,:,:) = pi*cos(pi*x) - 5*pi*sin(5*pi*x)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call derxpv(output,input,diloc,sx,cfip6,csip6,cwip6,cfx6,csx6,cwx6,nxmsize,xsize(1),xsize(2),xsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("derxpv00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-13)
      endif

   end subroutine verif_derxpv_00

   ! Serial test
   @test
   subroutine verif_interxpv_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(nxmsize,xsize(2),xsize(3)) :: input
      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: diloc, output, sol
      real(mytype) :: x, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: i

      ! Lx = Ly = Lz = 2
      do i = 1, nxmsize
         x = (i-half) * dx
         input(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo

      ! test derxvp
      do i = 1, xsize(1)
         x = (i-1) * dx
         sol(i,:,:) = sin(pi*x) + cos(5*pi*x)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call interxpv(output,input,diloc,sx,cifip6,cisip6,ciwip6,cifx6,cisx6,ciwx6,nxmsize,xsize(1),xsize(2),xsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("interxpv00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=7.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=6.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=4.d-13)
      endif

   end subroutine verif_interxpv_00

   ! Serial test
   @test
   subroutine verif_filx_00()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: input, output, sol
      real(mytype) :: x, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: i

      call filter(zero)

      ! Lx = Ly = Lz = 2
      do i = 1, xsize(1)
         x = (i-1) * dx
         input(i,:,:) = sin(pi*x) + cos(5*pi*x)
         sol(i,:,:) = input(i,:,:)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call filx(output,input,di1,fisx,fiffxp,fifsxp,fifwxp,xsize(1),xsize(2),xsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("filx00p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-11)
         @assertEqual(l2/sl2, 0.d0, tolerance=1.d-11)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif
      call cpu_time(t1)
      call filx(output,input,di1,fisx,fiffx ,fifsx ,fifwx ,xsize(1),xsize(2),xsize(3),0)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("filx00", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-11)
         @assertEqual(l2/sl2, 0.d0, tolerance=1.d-11)
         @assertEqual(linf/slinf, 0.d0, tolerance=7.d-12)
      endif

   end subroutine verif_filx_00

end module testx00
