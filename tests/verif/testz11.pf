module testz11

   use MPI
   use pFunit
   use iso_c_binding
   use x3d_unit_testing_tools
   implicit none

contains

   ! Serial test
   @test
   subroutine verif_derz_derzz_11()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf
      use ibm, only : ubcx,ubcy,ubcz

      implicit none

      real(mytype), dimension(zsize(1),zsize(2),zsize(3)) :: input, output, sol
      real(mytype) :: z, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: k

      ! Lx = Ly = Lz = 2
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = sin(5*pi*z)
         sol(:,:,k) = 5*pi*cos(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call ibm_derz(output,input,di3,sz,ffz,fsz,fwz,zsize(1),zsize(2),zsize(3),0,ubcy)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call log("derz11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=4.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=4.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=5.d-13)
      endif
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = cos(5*pi*z)
         sol(:,:,k) = -5*pi*sin(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call ibm_derz(output,input,di3,sz,ffzp,fszp,fwzp,zsize(1),zsize(2),zsize(3),1,ubcz)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call log("derz11p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=4.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=4.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=5.d-13)
      endif

      ! test derxx
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = cos(5*pi*z)
         sol(:,:,k) = -25*(pi**2)*cos(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call ibm_derzz(output,input,di3,sz,sfzp,sszp,swzp,zsize(1),zsize(2),zsize(3),1,ubcy)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call log("derzz11p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-12)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-12)
         @assertEqual(linf/slinf, 0.d0, tolerance=6.d-12)
      endif
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = sin(5*pi*z)
         sol(:,:,k) = -25*(pi**2)*sin(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call ibm_derzz(output,input,di3,sz,sfz,ssz,swz,zsize(1),zsize(2),zsize(3),0,ubcz)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call log("derzz11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-12)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-12)
         @assertEqual(linf/slinf, 0.d0, tolerance=6.d-12)
      endif

   end subroutine verif_derz_derzz_11

   ! Serial test
   @test
   subroutine verif_derzvp_11()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(zsize(1),zsize(2),zsize(3)) :: input, diloc
      real(mytype), dimension(zsize(1),zsize(2),nzmsize) :: output, sol
      real(mytype) :: z, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: k

      ! Lx = Ly = Lz = 2
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = sin(5*pi*z)
      enddo

      ! test derzvp
      do k = 1, nzmsize
         z = (k-half) * dz
         sol(:,:,k) = 5*pi*cos(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), nzmsize, xsize(1)*ysize(2)*nzmsize)
      call cpu_time(t1)
      call derzvp(output,input,diloc,sz,cfz6,csz6,cwz6,zsize(1),zsize(2),zsize(3),nzmsize,0)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), nzmsize, xsize(1)*ysize(2)*nzmsize)
      call log("derzvp11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-13)
      endif

   end subroutine verif_derzvp_11

   ! Serial test
   @test
   subroutine verif_interzvp_11()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(zsize(1),zsize(2),zsize(3)) :: input, diloc
      real(mytype), dimension(zsize(1),zsize(2),nzmsize) :: output, sol
      real(mytype) :: z, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: k

      ! Lx = Ly = Lz = 2
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = cos(5*pi*z)
      enddo

      ! test derzvp
      do k = 1, nzmsize
         z = (k-half) * dz
         sol(:,:,k) = cos(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), nzmsize, xsize(1)*ysize(2)*nzmsize)
      call cpu_time(t1)
      call interzvp(output,input,diloc,sz,cifzp6,ciszp6,ciwzp6,zsize(1),zsize(2),zsize(3),nzmsize,1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), nzmsize, xsize(1)*ysize(2)*nzmsize)
      call log("interzvp11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=8.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=8.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=8.d-13)
      endif

   end subroutine verif_interzvp_11

   ! Serial test
   @test
   subroutine verif_derzpv_11()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(zsize(1),zsize(2),nzmsize) :: input
      real(mytype), dimension(zsize(1),zsize(2),zsize(3)) :: diloc, output, sol
      real(mytype) :: z, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: k

      ! Lx = Ly = Lz = 2
      do k = 1, nzmsize
         z = (k-half) * dz
         input(:,:,k) = cos(5*pi*z)
      enddo

      ! test derzvp
      do k = 1, zsize(3)
         z = (k-1) * dz
         sol(:,:,k) = -5*pi*sin(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call derzpv(output,input,diloc,sz,cfip6z,csip6z,cwip6z,cfz6,csz6,cwz6,zsize(1),zsize(2),nzmsize,zsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call log("derzpv11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-13)
      endif

   end subroutine verif_derzpv_11

   ! Serial test
   @test
   subroutine verif_interzpv_11()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf

      implicit none

      real(mytype), dimension(zsize(1),zsize(2),nzmsize) :: input
      real(mytype), dimension(zsize(1),zsize(2),zsize(3)) :: diloc, output, sol
      real(mytype) :: z, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: k

      ! Lx = Ly = Lz = 2
      do k = 1, nzmsize
         z = (k-half) * dz
         input(:,:,k) = cos(5*pi*z)
      enddo

      ! test derzvp
      do k = 1, zsize(3)
         z = (k-1) * dz
         sol(:,:,k) = cos(5*pi*z)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call cpu_time(t1)
      call interzpv(output,input,diloc,sz,cifip6z,cisip6z,ciwip6z,cifz6,cisz6,ciwz6,zsize(1),zsize(2),nzmsize,zsize(3),1)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf, zsize(1), zsize(2), zsize(3), xsize(1)*ysize(2)*zsize(3))
      call log("interzpv11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=8.d-13)
         @assertEqual(l2/sl2, 0.d0, tolerance=8.d-13)
         @assertEqual(linf/slinf, 0.d0, tolerance=8.d-13)
      endif

   end subroutine verif_interzpv_11

   ! Serial test
   @test
   subroutine verif_filz_11()

      use decomp_2d
      use param
      use var
      use variables
      use tools, only : error_l1_l2_linf
      use ibm, only : ubcx,ubcy,ubcz

      implicit none

      real(mytype), dimension(xsize(1),xsize(2),xsize(3)) :: input, output, sol
      real(mytype) :: z, l1, l2, linf, sl1, sl2, slinf, t1, t2
      integer :: k

      call filter(zero)

      ! Lx = Ly = Lz = 2
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = cos(5*pi*z)
         sol(:,:,k) = input(:,:,k)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call ibm_filz(output,input,di3,fisz,fiffzp,fifszp,fifwzp,zsize(1),zsize(2),zsize(3),1,ubcy)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("filz11p", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-11)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-11)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-11)
      endif
      do k = 1, zsize(3)
         z = (k-1) * dz
         input(:,:,k) = sin(pi*z)
         sol(:,:,k) = input(:,:,k)
      enddo
      call error_l1_l2_linf(sol, sl1, sl2, slinf)
      call cpu_time(t1)
      call ibm_filz(output,input,di3,fisz,fiffz ,fifsz ,fifwz ,zsize(1),zsize(2),zsize(3),0,ubcz)
      call cpu_time(t2)
      call error_l1_l2_linf(output-sol, l1, l2, linf)
      call log("filz11", l1/sl1, l2/sl2, linf/slinf, t2-t1)
      if (check_error) then
         @assertEqual(l1/sl1, 0.d0, tolerance=2.d-11)
         @assertEqual(l2/sl2, 0.d0, tolerance=2.d-11)
         @assertEqual(linf/slinf, 0.d0, tolerance=2.d-11)
      endif

   end subroutine verif_filz_11

end module testz11
